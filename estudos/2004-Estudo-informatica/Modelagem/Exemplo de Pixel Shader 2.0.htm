<html><head>
<style type="text/css">
<!--
.just {text-align: justify;}
a {text-decoration: none}a:hover {text-decoration: underline; color: #504450}
BODY {
scrollbar-face-color:#808080;
scrollbar-highlight-color:#B8B4B8;s
scrollbar-3dlight-color:#808088;
scrollbar-darkshadow-color:#808088;
scrollbar-shadow-color:#B8B4B8;
scrollbar-arrow-color:#C0BCC0;
scrollbar-track-color:#E0E0E0;
}
-->
</style><title>Untitled Document</title>


<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!-- base -->
<link rel="icon" href="http://www.unidev.com.br/artigos/favicon.ico" type="image/ico"><link rel="SHORTCUT ICON" href="http://www.unidev.com.br/artigos/favicon.ico"><style type="text/css">
<!--
BODY {
scrollbar-face-color:#EAEEF4;
scrollbar-highlight-color:#FFFFFF;
scrollbar-3dlight-color:#EAEEF4;
scrollbar-darkshadow-color:#EAEEF4;
scrollbar-shadow-color:#9FB5D2;
scrollbar-arrow-color:#4D6185;
scrollbar-track-color:#F4F1EC;
}
-->
</style></head>


<body onload="" leftmargin="0" topmargin="0" alink="#504450" bgcolor="#000000" link="#504450" marginheight="0" marginwidth="0" text="#504450" vlink="#504450">

<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>

<form action="../xp_autentica.asp" method="post">

<div align="center">
  <center>
  <table border="0" cellpadding="0" cellspacing="0" width="783">
    <tbody><tr>
      <td width="781">
  
  
	





<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>
    <div align="center">
      <center>    
      <table style="border-collapse: collapse;" id="AutoNumber2" border="0" bordercolor="#234970" cellpadding="0" cellspacing="0" width="780">
      <tbody><tr>
        <td background="Exemplo%20de%20Pixel%20Shader%202.0_files/barsuplogo.jpg" height="20"><b>
        <font face="Verdana" size="2">&nbsp;<font color="#ffffff">
        </font>
        <font color="#234970">Olá, deus.oke!&nbsp;</font>&nbsp;&nbsp;
        </font>
        <a href="http://www.unidev.com.br/logout.asp"><font color="#234970" face="verdana, arial, helvética" size="1">[logout]</font></a></b></td>
      </tr>
      <tr>
        <td background="Exemplo%20de%20Pixel%20Shader%202.0_files/UDTOPBG.GIF" height="88" width="100%">
        <table style="border-collapse: collapse;" id="AutoNumber9" border="0" bordercolor="#234970" cellpadding="0" cellspacing="0" width="100%">
          <tbody><tr>
            <td width="25%">
            <a href="http://www.unidev.com.br/">
            <img src="Exemplo%20de%20Pixel%20Shader%202.0_files/UDTITLE.JPG" border="0"></a></td>
            <td align="center" width="14%">
            <a href="http://www.unidev.com.br/">
            <img src="Exemplo%20de%20Pixel%20Shader%202.0_files/logo_unidevBco1.gif" border="0" height="79" width="100"></a></td>
            <td width="100%">
            <iframe name="mainFrame" border="0" framespacing="0" src="Exemplo%20de%20Pixel%20Shader%202.0_files/banner.htm" frameborder="0" height="68" width="400"></iframe>            
</td>
          </tr>
          <tr>
            <td colspan="3" width="100%">            <table style="border-collapse: collapse;" id="AutoNumber26" border="0" bordercolor="#111111" cellpadding="0" cellspacing="0" height="15" width="100%">
              <tbody><tr>
                <td bgcolor="#000000" height="15" width="50%">
      <center><b><font face="Verdana, arial, helvética" size="2">
      <a href="http://www.unidev.com.br/forum/topic.asp?TOPIC_ID=6932"><font color="#ffffff">comente sobre este artigo no fórum</font></a><font color="#ffffff">
      </font></font></b></center>

   </td>
                <td bgcolor="#000000" height="15" width="50%"><p align="center"><b><a href="javascript:MM_openBrWindow('../mailfriendart.asp?artigo=/artigos/ps2basic000.asp','','scrollbars=no,width=350,height=490')"><font color="#ffffff" face="verdana, arial, helvética" size="2">Indique
este artigo para um amigo</font></a></b></p></td>
              </tr>
            </tbody></table>
            </td>
          </tr>
              
        </tbody></table>
        </td>
      </tr>
    </tbody></table></center>
    </div>
      
      </td>
    </tr>
    <tr>
      <td valign="top" width="820">
  
  &nbsp;
      <div align="center">
        <center>
        <table border="0" cellpadding="0" cellspacing="0" width="97%">
        <tbody><tr>
          <td width="100%">
            <p align="center"><span class="title"><font color="#ffffff" face="Verdana" size="5"><b>Exemplo
            de Pixel Shader 2.0</b></font></span><font color="#ffffff" face="Verdana" size="2"><br>
            </font><span class="author"><font color="#ffffff" face="Verdana" size="2">por
            </font><a href="mailto:brl@acm.org">
            <font color="#ffffff" face="Verdana" size="2"><b>Ben
            Landon</b></font></a><b><font color="#ffffff" face="Verdana" size="2"><br>
            </font></b><font color="#ffffff" face="Verdana" size="2">Traduzido
            por </font><a href="mailto:willianpolis@bol.com.br"><b><font color="#ffffff" face="Verdana" size="2">Willian
            Polis</font></b></a></span></p><p align="justify"><b>
            <font color="#ffffff" face="Verdana" size="4">Introdução</font></b></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">A
            liberação do <b>Microsoft DirectX 9</b> permite que você escreva shaders
            programáveis usando a versão 2.0 (ps 2.0) do conjunto de instruções
            do pixel shader. A versão 2.0 do pixel shader nos dá
            muito mais instruções aritméticas, mais registradores e um número
            de instruções por programa maior do que havia na versão 1.4 (ps
            1.4).</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Todas estas características adicionadas tornam o ps 2.0 algo que
            vale a pena aprender, e por isto ele ainda está na margem principal da
            programação de pixel shader, não existem muitos exemplos ou
            tutoriais descrevendo como escrever um shader com ps 2.0. Até onde eu
            sei, não existem exemplos do uso do ps 2.0 em um programa na
            documentação DirectX 9 SDK. Eu estou confiante que a Microsoft irá
            produzir exemplo e documentação para usar ps 2.0, mas por enquanto
            aqui está um pequeno exemplo para você poder iniciar. Este
            tutorial discute um simples pixel shader que simplesmente aplica a 
            cor da textura.<br>
            </font>
            <font color="#ffffff" face="Verdana" size="1"><i>Nota do editor: 
            quando este artigo foi escrito não, mas agora, na atualização de 
            verão do DirectX já foram adicionados os exemplos de pixel shader.</i></font><font color="#ffffff" face="Verdana" size="2"><br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; Um pixel shader simples
; Ele usa a instrução ps 2.0 e registradores
ps_2_0
; 
; Declarar o  registrador s0 para ser o sampler para o estágio 0
dcl_2d s0


; Declarar t0 para ter as coordenadas de textura 2D 
; do estágio 0. Estes são interpolados
; pelas coordenadas de textura.
dcl t0.xy


; Copiar a textura no estágio 0 para o registrador temporário r1
texld r1, t0, s0


; mover r1 para o registrador de saída
mov oC0, r1</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O
            tutorial assume que você já esteja familiarizado com o DirectX na
            versão 8 ou 9. Ele também supõe que você já saiba como
            inicializar o DirectX, criar um dispositivo de objeto, criar e
            carregar um vertex buffer, carregar uma textura de um arquivo e
            renderizar um cenário. Se você não está familiarizado com estas
            operações você pode  ver todo o código fonte que acompanha
            este tutorial. Todos estes passos são bem descritos na documentação
            do DirectX 9 SDK nos tópicos "Tutorial 1: Creating a
            Device", "Tutorial 2: Rendering Vertices" e
            "Tutorial 5: Using Texture Maps".</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Para iniciar você irá precisar do Microsoft DirectX 9.0 runtime e
            do SDK. Eles estão disponíveis em:<br>
            </font><b>
            <a target="_blank" href="http://msdn.microsoft.com/library/default.asp?url=/downloads/list/directx.asp"><font color="#ffffff" face="Verdana" size="2">http://msdn.microsoft.com/library/default.asp?url=/downloads/list/directx.asp</font></a></b></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Em um programa C++, comece criando os objetos Direct3D e
            Direct3DDevice.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
#include &lt;d3d9.h&gt;  
#include &lt;d3dx9.h&gt; // Necessário para D3DXCreateTextureFromFile 

IDirect3D9* lpD3D = Direct3DCreate9(D3D_SDK_VERSION);</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Um problema que você encontra agora é o de criar um dispositivo
            HAL ou REF. Um dispositivo HAL (Hardware Abstraction Layer - Camada
            de Abstração de Hardware) representa seu hardware gráfico, logo
            isto é algo bom e rápido. Um dispositivo REF (o rasterizador de
            referência) é uma interface Direct3DDevice9 implementada em
            software, logo ela possui muitas características, porém lenta. O
            problema com a criação de um dispositivo HAL é que muito poucas
            placas de vídeo no mercado atual suportam ps 2.0. Até o que eu
            sei, somente a ATI RADEON 9700 atualmente suporta ps 2.0 em
            hardware.<br>
            </font>
            <font color="#ffffff" face="Verdana" size="1"><i>Nota do editor: a 
            série FX da GeForce (NVIDIA) também oferece suporte a ps_2_0.</i></font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Você pode checar se sua placa de vídeo suporta o ps 2.0 usando o
            IDirect3D9::GetDeviceCaps.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
D3DCAPS9 hal_caps;
ZeroMemory(&amp;hal_caps, sizeof(D3DCAPS9)); // A struct não pode ser danificada à zero.

HRESULT hRes = lpD3D-&gt;GetDeviceCaps(D3DADAPTER_DEFAULT,
                                    D3DDEVTYPE_HAL,
                                    &amp;hal_caps);
</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Você pode ver as macros D3DSHADER_VERSION_MAJOR e
            D3DSHADER_VERSION_MINOR para determinar a versão do pixel shader
            suportada pelo seu HAL.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
UINT ps_major = D3DSHADER_VERSION_MAJOR(hal_caps.PixelShaderVersion);
UINT ps_minor = D3DSHADER_VERSION_MINOR(hal_caps.PixelShaderVersion);

// Se tudo estiver certo, o ps_major deve ser 2 e ps_minor 
// deve ser 0.</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Você também pode usar o D3DPS_VERSION para comparar seu suporte
            pixel shader em seu HAL com algum valor que você queira.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
if (hal_caps.PixelShaderVersion &lt; D3DPS_VERSION(2, 0)) 
{
        // Nós teremos que usar o dispositivo REF ou 
        // configurá-lo para um número menor de versão do pixel shader. 
}</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Como
            este tutorial está preocupado com o uso do ps 2.0, nós iremos usar
            o dispositivo REF se o ps 2.0 não for suportado pelo dispositivo
            HAL. Usar o dispositivo REF provavelmente não é uma estratégia
            completa de desenvolvimento mas isto será o suficiente para as
            propostas deste tutorial.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Agora você precisa criar o dispositivo de uma forma não usual,
            usando o IDirect3D9::CreateDevice. Crie também um vertex buffer,
            configure o stream source e o FVF (flexible vertex format). O código
            fonte que acompanha este tutorial usa um quadro simples e o formato
            de vértice é D3DFVF_XYZRHW|D3DFVF_DIFFUSE|D3DFVF_TEX1. O único preço
            requerido deste formato de vértice é o D3DFVF_TEX1. Deverá haver pelo
            menos um conjunto de coordenadas de textura armazenada com cada
            vértice, caso contrário o texture mapping não funcionará corretamente.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">A próxima coisa importante que você tem que fazer antes de
            renderizar nosso cenário é criar uma textura de teste. Eu recomendo
            usar o D3DXCreateTextureFromFile (Nota: Para usar as funções D3DX
            você precisa adicionar o d3dx9.lib para a lista de bibliotecas que
            você linka, o que também requer que você linke com a
            advapi32.lib). Você pode usar o D3DXCreateTextureFromFile para
            carregar uma textura de um formato de imagem comum como BMP e JPEG.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
IDirect3DTexture9* lpTexture = NULL;
hRes = D3DXCreateTextureFromFile(lpDevice, // seu IDirect3DDevice9* 
                                 "filename.jpg", 
                                  &amp;lpTexture);


// Assegure-se que você checa seus códigos de retorno.  </font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O próximo passo é configurar a textura no estágio 0 da textura.
            Você pode usar qualquer um dos estágios de textura que são
            suportados pelo seu dispositivo mas este exemplo assume que a
            textura está no estágio 0.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
hRes = lpDevice-&gt;SetTexture(0, lpTexture);</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Nós terminamos com a interface lpTexture logo nós podemos seguir
            com sua liberação. Desta forma ela será limpada quando nós
            liberarmos o dispositivo ou configurar uma outra textura no estágio
            0.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
lpTexture-&gt;Release();
lpTexture = NULL;</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Agora nós estamos prontos para mergulhar no código 
            do ps 2.0. Em um
            arquivo separado, usando seu editor de texto favorito, você pode
            editar seu pixel shader no DX9 através da linguagem assembly. O código C++ que acompanha esta nota assume que o
            programa pixel shader está em um arquivo separado chamado
            "simple_texture_map.ps".</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Conforme as versões anteriores dos pixel shaders 
            do DirectX,
            todo pixel shader precisa começar com uma instrução ps. Para o ps
            2.0, a instrução é ps_2_0. Note que o ponto-e-vírgula é usado
            para denotar um comentário na linguagem pixel shader assembly.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; Aqui está a primeira instrução em um pixel shader 
ps_2_0</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O próximo passo no pixel shader é declarar o registrador s0. Isto
            significa dizer ao shader que nós vamos usar o s0 (um registrador
            sampler de entrada de textura) para exemplificar a configuração de
            textura no estágio 0. Defina aquela textura que foi configurada no
            estágio 0 no programa C++ usando o IDirect3DDevice9::SetTexture.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; Declarar o registrador sampler s0 como um mapa de textura 2D
dcl_2d s0 </font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Existem também as instruções dcl_ para cube maps e volume maps:
            dcl_cube e dcl_volume, respectivamente. Os registradores sampler são
            novos no ps 2.0.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O próximo passo no pixel shader é declarar t0, um registrador de
            entrada de coordenada de textura como coordenadas de texturas 2D
            interpoladas. Esta declaração é um novo requerimento no ps 2.0.
            No 1.4, os registradores de coordenada de textura de entrada somente
            guardavam automaticamente as coordenadas interpoladas. Também
            é importante apontar que o ps 2.0, assim como o ps 1.4, refere-se
            aos dados de textura e as coordenadas de textura em registradores
            separados. No ps 2.0, os dados de textura do sampler é referido
            para um registrador s# e as coordenadas de textura interpolada estão
            tipicamente em um registrador t#, onde '#' é algum dígito
            identificando o registrador especificado.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; Declarar o registrador t0 como tendo as coordenadas de textura interpolada
; tornando-se a textura que está sendo exemplificada no estágio 0.
dcl t0.xy</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O modificador .xy é usado para indicar que as coordenadas de
            textura possuem somente dois valores.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Agora nós na verdade exemplificamos a textura no estágio 0 usando
            as coordenadas de textura a partir de t0.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" height="119" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" height="97" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; Usar as coordenadas de textura no t0 e a textura sampler no s0 para
; exemplificar a textura no estágio 0. Isto exemplifica a textura e carrega
; o resultado no registrador temporário r1.  
texld r1, t0, s0</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Você pode escolher qualquer um dos registradores temporários com
            sua meta para a instrução texld, não existe nada especial sobre o
            r1.<br>
            <br>
            No ps 2.0, r0 não é a saída do seu shader como era nas
            versões anteriores do pixel shader. Cada pixel shader escrito
            usando ps 2.0 deve escrever para o registrador de saída oC0 ou seu
            pixel shader não terá sucesso. Eu acredito que oC0 significa
            "output color 0 - saída de cor 0". Existem outros
            registradores de saída mas todos os pixel shaders devem pelo menos
            escrever no oC0.<br>
            <br>
            O último passo neste simples pixel shader é:<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
; mover r1 to para o registrador de saída
mov oC0, r1</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Isto simplesmente move a cor que é exemplificada a partir da
            textura para o registrado de saída. Você pode estar pensando
            porque o programa não usa o oC0 como alvo da instrução texld,
            isto por que uma das regras do ps 2.0 é que o oC0 só pode ser
            escrito usando uma função mov.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O próximo passo é voltar ao programa C++. Nós temos que montar o
            arquivo pixel shader e dizer ao dispositivo usar tal pixel shader ao
            invés do shader da fixed function pipeline.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
// Montar e configurar o pixel shader 
IDirect3DPixelShader9* lpPixelShader = NULL;
LPD3DXBUFFER pCode = NULL;
LPD3DXBUFFER pErrorMsgs = NULL;

hRes = D3DXAssembleShaderFromFile("simple_texture_map.ps",  
				    NULL,		    
				    NULL, 
				    0,
                                    &amp;pCode, 
				    &amp;pErrorMsgs);
</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O parâmetro pErrorMsgs para D3DXAssembleShaderFromFile é opcional,
            mas eu sugiro que você use este parâmetro uma vez que ele é de
            uma ajuda muito valiosa para seu programa pixel shader. As mensagens
            de erro do assembler são úteis e você as verá se você inserir
            este bloco de código depois da chamada para
            D3DXAssembleShaderFromFile:<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
if ((FAILED(hRes)) &amp;&amp; (lpErrorMsgs != NULL))
{
    unsigned char* message = (unsigned char*)pErrorMsgs-&gt;GetBufferPointer();
    // Outro erro de manipulação aqui. 
}</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">No debugger, você pode colocar um breakpoint (ponto de parada) na
            chamada de pErrorMsgs-&gt;GetBufferPointer() para ver qual foi o
            erro com o shader. Obviamente isto simplesmente dirá a você sobre
            os erros em assembly no shader, não erros de runtime.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Depois que o shader foi montado com sucesso, você pode configurar o
            shader usando o IDirect3DDevice9::CreatePixelShader e o
            IDirect3DDevice9::SetPixelShader.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
hRes = g_lpDevice-&gt;CreatePixelShader((DWORD*)pCode-&gt;GetBufferPointer(), 
                                         &amp;lpPixelShader);
if (FAILED(hRes)) return false;

hRes = g_lpDevice-&gt;SetPixelShader(lpPixelShader);
if (FAILED(hRes)) return false;</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Se você quer ter certeza que o pixel shader está funcionando sem a
            adição da complexidade de texturas, você pode simplesmente
            escrever um valor constante para o registrador de saída. Por
            exemplo, um pixel shader pode escrever vermelho para cada
            pixel. Isto não é muito interessante, mas ele pode ajudá-lo a ter
            certeza que o shader, criação e execução estão funcionando.<br>
            <br>
            Aqui está um simples pixel shader que sempre tem como saída uma
            cor constante:<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">
ps_2_0
def c0, 1.0, 0.0, 0.0, 1.0
mov oC0, c0
</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">A instrução def só configura o valor de um registrador constante.
            Ele é equivalente a chamada de
            IDirect3DDevice9::SetPixelShaderConstantF do programa C++.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">É isto. Como o shader discutido aqui não é algo tão complexo, eu
            espero que ele seja de utilidade para você.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">O código fonte completo para este tutorial pode ser encontrado nos
            arquivos simple_texture_map.cpp e simple_texture_map.ps. Ele assume
            que você tenha um arquivo de teste chamado test.jpg no mesmo diretório.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Download:</font><font color="#00ff00" face="Verdana" size="2"> </font><b>
            <a href="http://www.unidev.com.br/artigos/article_ps2_tutorial.zip"><font color="#ffffff" face="Verdana" size="2">article_ps2_tutorial.zip</font></a></b><font color="#00ff00" face="Verdana" size="2">
            </font><font color="#ffffff" face="Verdana" size="2">(26k)</font></p></td>
        </tr>
      </tbody></table>
      </center>
    </div>
      </td>
    </tr>
  </tbody></table>
</center></div>

<p align="center"><b><a href="javascript:MM_openBrWindow('../mailfriendart.asp?artigo=/artigos/ps2basic000.asp','','scrollbars=no,width=350,height=490')"><font color="#ffffff" face="verdana, arial, helvética" size="2">Indique
este artigo para um amigo</font></a></b></p>
</form></body></html>