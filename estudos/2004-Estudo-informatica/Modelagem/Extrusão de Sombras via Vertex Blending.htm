<html><head>
<style type="text/css">
<!--
.just {text-align: justify;}
a {text-decoration: none}a:hover {text-decoration: underline; color: #504450}
BODY {
scrollbar-face-color:#808080;
scrollbar-highlight-color:#B8B4B8;s
scrollbar-3dlight-color:#808088;
scrollbar-darkshadow-color:#808088;
scrollbar-shadow-color:#B8B4B8;
scrollbar-arrow-color:#C0BCC0;
scrollbar-track-color:#E0E0E0;
}
-->
</style><title>Untitled Document</title>


<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<!-- base -->
<link rel="icon" href="http://www.unidev.com.br/artigos/favicon.ico" type="image/ico"><link rel="SHORTCUT ICON" href="http://www.unidev.com.br/artigos/favicon.ico"><style type="text/css">
<!--
BODY {
scrollbar-face-color:#EAEEF4;
scrollbar-highlight-color:#FFFFFF;
scrollbar-3dlight-color:#EAEEF4;
scrollbar-darkshadow-color:#EAEEF4;
scrollbar-shadow-color:#9FB5D2;
scrollbar-arrow-color:#4D6185;
scrollbar-track-color:#F4F1EC;
}
-->
</style></head>


<body onload="" leftmargin="0" topmargin="0" alink="#504450" bgcolor="#000000" link="#504450" marginheight="0" marginwidth="0" text="#504450" vlink="#504450">

<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>

<form action="../xp_autentica.asp" method="post">

<div align="center">
  <center>
  <table border="0" cellpadding="0" cellspacing="0" width="783">
    <tbody><tr>
      <td width="781">
  
  
	





<script language="JavaScript">
<!--
function MM_openBrWindow(theURL,winName,features) { //v2.0
  window.open(theURL,winName,features);
}
//-->
</script>
    <div align="center">
      <center>    
      <table style="border-collapse: collapse;" id="AutoNumber2" border="0" bordercolor="#234970" cellpadding="0" cellspacing="0" width="780">
      <tbody><tr>
        <td background="Extrus%E3o%20de%20Sombras%20via%20Vertex%20Blending_files/barsuplogo.jpg" height="20"><b>
        <font face="Verdana" size="2">&nbsp;<font color="#ffffff">
        </font>
        <font color="#234970">Olá, deus.oke!&nbsp;</font>&nbsp;&nbsp;
        </font>
        <a href="http://www.unidev.com.br/logout.asp"><font color="#234970" face="verdana, arial, helvética" size="1">[logout]</font></a></b></td>
      </tr>
      <tr>
        <td background="Extrus%E3o%20de%20Sombras%20via%20Vertex%20Blending_files/UDTOPBG.GIF" height="88" width="100%">
        <table style="border-collapse: collapse;" id="AutoNumber9" border="0" bordercolor="#234970" cellpadding="0" cellspacing="0" width="100%">
          <tbody><tr>
            <td width="25%">
            <a href="http://www.unidev.com.br/">
            <img src="Extrus%E3o%20de%20Sombras%20via%20Vertex%20Blending_files/UDTITLE.JPG" border="0"></a></td>
            <td align="center" width="14%">
            <a href="http://www.unidev.com.br/">
            <img src="Extrus%E3o%20de%20Sombras%20via%20Vertex%20Blending_files/logo_unidevBco1.gif" border="0" height="79" width="100"></a></td>
            <td width="100%">
            <iframe name="mainFrame" border="0" framespacing="0" src="Extrus%E3o%20de%20Sombras%20via%20Vertex%20Blending_files/banner.htm" frameborder="0" height="68" width="400"></iframe>            
</td>
          </tr>
          <tr>
            <td colspan="3" width="100%">            <table style="border-collapse: collapse;" id="AutoNumber26" border="0" bordercolor="#111111" cellpadding="0" cellspacing="0" height="15" width="100%">
              <tbody><tr>
                <td bgcolor="#000000" height="15" width="50%">
      <center><b><font face="Verdana, arial, helvética" size="2">
      <a href="http://www.unidev.com.br/forum/topic.asp?TOPIC_ID=4862"><font color="#ffffff">comente sobre este artigo no fórum</font></a><font color="#ffffff">
      </font></font></b></center>

   </td>
                <td bgcolor="#000000" height="15" width="50%"><p align="center"><b><a href="javascript:MM_openBrWindow('../mailfriendart.asp?artigo=/artigos/shadowextrvb000.asp','','scrollbars=no,width=350,height=490')"><font color="#ffffff" face="verdana, arial, helvética" size="2">Indique
este artigo para um amigo</font></a></b></p></td>
              </tr>
            </tbody></table>
            </td>
          </tr>
              
        </tbody></table>
        </td>
      </tr>
    </tbody></table></center>
    </div>
      
      </td>
    </tr>
    <tr>
      <td valign="top" width="820">
  
  &nbsp;
      <div align="center">
        <center>
        <table border="0" cellpadding="0" cellspacing="0" width="97%">
        <tbody><tr>
          <td width="100%">
            <p align="center"><b><font color="#ffffff" face="Verdana" size="5"><span class="title">Extrusão de Sombras via Vertex Blending</span></font><font size="5"><br>
            </font></b>
            <span class="author"><font color="#ffffff" face="Verdana" size="2">por
            </font><b><a href="mailto:arne9184@yahoo.com"><font color="#ffffff" face="Verdana" size="2">Arne
            Olav Hallingstad</font></a><font color="#ffffff" face="Verdana" size="2"><br>
            </font></b><font color="#ffffff" face="Verdana" size="1">Traduzido
            por </font><a href="mailto:willianpolis@bol.com.br"><b>
            <font color="#ffffff" face="Verdana" size="1">Willian
            Polis</font></b></a></span></p><p align="justify"><b>
            <font color="#ffffff" face="Verdana" size="4">Introdução</font></b><font color="#ffffff" face="Verdana" size="2"><br>
            Um dos dois maiores algoritmos de sombras é o algoritmo de volume de
            sombra. Uma excelente revisão foi feita por Eric Lengyel </font><a href="http://www.gamasutra.com/features/20021011/lengyel_01.htm" target="_blank"><b><font color="#ffffff" face="Verdana" size="2">(http://www.gamasutra.com/features/20021011/lengyel_01.htm)</font></b></a><font color="#ffffff" face="Verdana" size="2">,
            que mostra como implementar o algoritmo de forma robusta.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Implementar volumes 
            de sombra (shadow volumes) requer cálculos geométricos que tenham
            sido acelerados usando hardware gráfico programável. Este artigo
            mostra uma solução combinada entre CPU/GPU onde as placas de vídeo
            podem acelerar a extrusão de volume de sombra mesmo se uma unidade de
            vértices programáveis não esteja disponível.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Os cálculos de geometria necessários para volumes de sombras são
            a determinação de silhuetas e extrusão de silhueta. A determinação
            de silhueta encontra o contorno entre as regiões frente e costas em
            relação a origem de luz. A extrusão da silhueta então projeta
            qualquer vértice que é parte do contorno além da origem de luz, de
            preferência ao infinito.</font></p><p align="justify"><font color="#ffffff" face="Verdana" size="2">É possível executar todos os cálculos na GPU, mas ela requer um
            argumento geométrico que melhora o carregamento dos vértices no fator
            de 3. Um método alternativo só move a extrusão de silhueta para a
            GPU enquanto a CPU faz a determinação da silhueta </font><a href="http://developer.nvidia.com/docs/IO/8230/GDC2003_ShadowVolumes.pdf" target="_blank"><b><font color="#ffffff" face="Verdana" size="2">http://developer.nvidia.com/docs/IO/8230/GDC2003_ShadowVolumes.pdf</font></b></a><font color="#ffffff" face="Verdana" size="2">.
            Este link refere-se à solução CPU/GPU que este artigo irá focar.</font></p><p align="justify"><b>
            <font color="#ffffff" face="Verdana" size="4">Solução de
            Combinação CPU/GPU para Volumes de Sombras</font><font color="#ffffff" face="Verdana" size="2"><br>
            </font></b><font color="#ffffff" face="Verdana" size="2">Na solução
            de combinação CPU/GPU, a CPU faz a determinação da silhueta
            enquanto a GPU faz a extrusão da silhueta. A geometria é preparada
            de forma que cada vértice usado para o lançamento da sombra venha em
            duas versões, uma vez como (x, y, z, 0) e na outra vez como (x, y, z,
            1). Uma destas será projetada além da fonte de luz enquanto a
            outra mantém-se inalterada. Exatamente qual versão dos vértices
            é projetada, a sombra com w = 0 ou a sombra com w = 1, é uma
            implementação de escolha aleatória. A tarefa da CPU é escrever
            um índice de buffer que referencia as propriedades dos vértices
            para criar um volume de sombra, a região anterior frontal e a região
            anterior das costas.<br>
            <br>
            Para projetar um vértice no (x,y,z) a partir de uma fonte de luz nas
            coordenadas (lx, ly, lz) em direção ao infinito, a GPU precisa
            executar o seguinte cálculo:<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" height="71" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" height="49" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">x' = x - lx 
y' = y - ly 
z' = z - lz 
w' = 0</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">onde
(x', y', z', w') é o vértice projetado. Para fontes de luz direcionais,
todos os vértices são projetados para (-lx, -ly, -lz, 0), logo nenhum
cálculo por-vértice é necessário. Normalmente um vertex program é
empregado para executar a projeção, ou não, dependendo da coordenada w
do vértice de entrada.</font></p><p align="justify"><b>
            <font color="#ffffff" face="Verdana" size="4">Reformulação
            da Matriz</font></b><font color="#ffffff" face="Verdana" size="2"><br>
            A projeção descrita acima pode ser expressada na forma de matriz
            como a seguinte forma<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">| 1 0 0 -lx |
| 0 1 0 -ly |
| 0 0 1 -lz |
| 0 0 0 0   |</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Quando
multiplicada com a matriz modelo de visão (a matriz que transforma as
coordenadas do modelo para as coordenadas dos olhos), a matriz
resultante transformará os vértices das coordenadas de modelo
diretamente para a sua posição projetada no espaço da visão. A projeção
seletiva de vértices pode assim ser reformulada como uma transformação
seletiva do vértice, onde a coordenada w do vértice de entrada dita
qual matriz aplicar.<br>
            <br>
            Felizmente a transformação seletiva está disponível desde a
            primeira geração de hardware T&amp;L via vertex blending. Nós
            estabelecemos duas matrizes de transformação e configuramos o
            estado de renderização de modo a interpretar a coordenada w do 
            vértice de entrada como carga blend para uma transformação blended.
            Se nós temos matrizes de transformação M0 e M1, a carga blend w e
            o vertex original v, a operação passa a ser<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">v' = v * w * M0 + v * ( 1 - w ) * M1</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Quando
            M0 é a matriz que transforma os vértices do modelo de espaço no
            espaço de visão e M1 é uma matriz que transforma os vértices do
            modelo de espaço para sua posição projetada além da fonte de
            luz, como discutido acima, então todos os vértices que possuem w =
            0 são projetados além da fonte de luz enquanto os vértices que
            possuem w = retém sua posição original.<br>
            <br>
            </font><b><font color="#ffffff" face="Verdana" size="4">Código de
            Exemplo</font></b><font color="#ffffff" face="Verdana" size="2"><br>
            Eu forneci um exemplo de código de como configurar ponteiros vertex
            e matrizes em OpenGL, usando o GL_ARB_vertex_blend. Note que em
            DirectX, a mesma funcionalidade está disponível com o formato
            vertex D3DFVF_XYZB1.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">void SetupPointersARB( const float *verts )
{
  glVertexPointer( 3, GL_FLOAT, 16, verts );
  glWeightPointerARB( 1, GL_FLOAT, 16, verts + 3 );
  glEnable( GL_VERTEX_BLEND_ARB );
  glEnable( GL_WEIGHT_SUM_UNITY_ARB );
}</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Nesta
            função, o vetor de floats que é dado como parâmetro está
            supostamente apontando para um array de (x, y, z, w) valores. O
            GL_WEIGHT_SUM_UNITY está especificado como implícito para criar a
            carga para a segunda matriz complementar à carga da primeira. O
            código seguinte configurará as matriz modelview apropriadas:<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">void SetupMatrices( const float *modelview, const float *lightpos )
{
  glMatrixMode( GL_MODELVIEW0 );
  glLoadMatrixf( modelview );

  glMatrixMode( GL_MODELVIEW1 );
  glLoadMatrixf( modelview );

  const float pmatrix[16] = 
  {
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    -lightpos[0], -lightpos[1], -lightpos[2], 0,
  }

  glMatrixMultf( pmatrix );
}</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Nesta
função, o parâmetro modelview é a matriz que transforma das coordenadas
do modelo para as coordenadas da visão, enquanto o parâmetro lightpos é
um 3-vector especificando a posição da fonte de luz nas coordenadas de
visão.</font></p><p align="justify"><b>
            <font color="#ffffff" face="Verdana" size="4">Vertex
            Blending Não-Projetável</font></b><font color="#ffffff" face="Verdana" size="2"><br>
A vantagem é que existem implementações onde as matrizes projetivas não
são suportadas pelo vertex blending, pois o vertex blending foi
projetado originalmente para animação tweening ou softskinning. Quando
usar vertex blending para extrusão de volume de sombra, nós vemos o
problema de que uma de nossas matrizes está projetada. Como nós estamos
projetando para o infinito, a projeção consiste meramente em configurar
w = 0 em um vértice de saída. Se o hardware não permitir a projeção do
vertex blending, nós podemos criar um x, y e z imenso e reter o w = 1.
A substituição correta seria criar um x, y e z infinitamente largo,
algo que não é possível. Mas para propostas práticas, deve existir um
fator grande o bastante que trabalhe corretamente em uma dada situação.<br>
            <br>
            A alternativa da operação de projeção então fica<br>
            <br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">x' = ( x - lx ) * fator_grande
y' = ( y - ly ) * fator_grande
z' = ( z - lz ) * fator_grande
w' = 1</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">e a
            matriz correspondente é<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><b><font color="#000000" face="Courier New" size="2">| fator_grande 0 0 ( -lx * fator_grande ) | 
| 0 fator_grande 0 ( -ly * fator_grande ) |
| 0 0 fator_grande ( -lz * fator_grande ) |
| 0 0 0            1                      |</font></b></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><font color="#ffffff" face="Verdana" size="2">Agora que ambas as matrizes possuem a última linha como (0, 0, 0,
            1), nós podemos usá-lo mesmo para vertex blending não-projetável.
            O código de configuração é mostrado abaixo.<br>
            </font>
            <table bgcolor="#ffffff" border="1" cellpadding="10" cellspacing="0" width="90%">
              <tbody>
                <tr>
                  <td bgcolor="#ffffff" width="100%">
                    <div align="justify">
                      <pre><font color="#000000" face="Courier New" size="2"><b>void SetupMatrices( const float *modelview, const float *lightpos )
{
  glMatrixMode( GL_MODELVIEW0 );
  glLoadMatrixf( modelview );

  glMatrixMode( GL_MODELVIEW1 );
  glLoadMatrixf( modelview );

  const float LARGE = 16777216;

  const float pmatrix[16] = 
  {
    LARGE, 0, 0, 0,
    0, LARGE, 0, 0,
    0, 0, LARGE, 0,
    -lightpos[0] * LARGE, -lightpos[1] * LARGE, -lightpos[2] * LARGE, 1,
  }

  glMatrixMultf( pmatrix );
}
</b></font></pre>
                    </div>
                  </td>
                </tr>
              </tbody>
            </table>
            </p><p align="justify"><b><font color="#ffffff" face="Verdana" size="4">Conclusão</font></b><font color="#ffffff" face="Verdana" size="2"><br>
            Uma alternativa de acelerar a extrusão de volume de sombra,
            conforme foi mostrado, pode ser o hardware acelerado em qualquer
            placa T&amp;L.</font></p></td>
        </tr>
      </tbody></table>
      </center>
    </div>
      </td>
    </tr>
  </tbody></table>
</center></div>

<p align="center"><b><a href="javascript:MM_openBrWindow('../mailfriendart.asp?artigo=/artigos/shadowextrvb000.asp','','scrollbars=no,width=350,height=490')"><font color="#ffffff" face="verdana, arial, helvética" size="2">Indique
este artigo para um amigo</font></a></b></p>
</form></body></html>